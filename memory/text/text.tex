\documentclass[10pt]{article}
\renewcommand{\baselinestretch}{1.5}


\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{array}
\usepackage{tabularx}
\usepackage{setspace}
\usepackage{color}
\usepackage{url}
\usepackage{multicol}
\usepackage{amssymb}
\usepackage{hyperref}

\makeatletter
\renewcommand{\@biblabel}[1]{#1.} % Список литературы: `[1]' => `1.'
\makeatother

\usepackage{geometry} % Меняем поля страницы
\geometry{left=2.2cm}% левое поле
\geometry{right=2.2cm}% правое поле
\geometry{top=1.9cm}% верхнее поле

\newenvironment{rus_keywords}{
       \list{}{\advance\topsep by0.35cm\relax\small
       \leftmargin=1cm
       \labelwidth=0.35cm
       \listparindent=0.35cm
       \itemindent\listparindent
       \rightmargin\leftmargin}\item[\hskip\labelsep
                                     \bfseries Ключевые слова:]}
     {\endlist}

\newenvironment{eng_keywords}{
       \list{}{\advance\topsep by0.35cm\relax\small
       \leftmargin=1cm
       \labelwidth=0.35cm
       \listparindent=0.35cm
       \itemindent\listparindent
       \rightmargin\leftmargin}\item[\hskip\labelsep
                                     \bfseries Keywords:]}
     {\endlist}

\begin{document}
\section{Распространенные ошибки работы с память на языке с/с++}
\subsection{Средства отладки}
Так как языки программирования С и С++ являются теми языками, в которых отсутствует
сборщик мусора, и доступен прямой доступ к памяти компьютера, то, в силу человеческого
фактора, периодически могут возникать ошибки, связанные с управлением памятью.
Рассмотрим основные случаи, а затем покажем ряд советов, при соблюдении которых,и.
программист с высокой вероятностью избежит описанных проблем.
Для облегечения отладки ошибок, связанных с ошибками работы с памятью, существует несколько инструментов,
способных "отловить" ошибки работы с памятью. В докладе удем пользоваться бесплатным инструментом
valgrind. Его вывод прост и понятен, будет объяснен в ходе демонстрации ошибок.
\subsection{Основные ошибки}
Вкратце обозначим основные ошибки и рассмотрим каждую из них более подробно.
\begin{itemize}
	\item Переназначение указателей;
	\item Освобождение блока памяти, являющегося хранилищем указателей;
	\item Неправильная обработка возвращаемых значений;
	\item Некоторые функции библиотек С выделают память, которая должна быть освобождена;
	\item Разработчик забываетвызвать функцию освобождения выделенной памяти; 
	\item Ошибочное удаление в случае наследование;
	\item Применение собственного (а не по умолчанию) конструктора копирования для глубоких копий;
	\item Использование правильного оператора удалния delete[] для new[] (а не delete).
\end{itemize}

\subsection{Переназначение указателей}
В самом простом варианте данная ситуация возникает, когда сущестсвует два указателя.
Каждый из которых указывает на разные участки выделенной памяти. В указателе хранится
адрес выделенного блока памяти. Если переменной указателю присвоить значение другого
указателя, то получим две переменные, значением которых является адрес одного и того же юлока.
Соответственно, адрес второго выделенного блока утерян, и мы его не сможем освобоить. То есть
происходит утечка памяти, что подтверждается выводом программы valgrind. Для приведенного
примера потеряно 10 байт, так как была выделена область памяти для 10 объектов типа char,
где char занимает 1 байт.

% TODO: 1. indirect lost; 2. Rename block to parent on image 
\subsection{Освобождение блока памяти, являющегося хранилищем указателей}
Назовем блок памяти {\it родительским}, если ешл элементы
являются указатели на другие выделенные блоки. Если произвести освобождение памяти по указателю,
который указывает на родительский блок, то тогда будут удалены указатели на выделенные блоки,
но при этом память выделенныая память останется, и освободить ее будет невозможно, так как утеряны
указатели на блоки. НА слайде показан пример кода подобной ситуации. Утечку памяти подтверждает
вывод программы valgrind: утеряно 10 байт.

В предыдущем примере произошло удаление блока памяти, на который указывал
родительский указатель. Если же родительскому указателю присвоить какое-то другой 
адрес, то, помимо directly lost утечки, мы увидим другую утечку: indirectly lost.

\subsection{Неправильное управление возвращаемых значений}
Допустим, происходит вызов некоторой функции, которая выделяет блок памяти
и возвращает указатель на него. Необходимо правильно управлять возращенным значением,
то есть запомнить возращенное значение указателя и освободить память, на которую он указывает.
В примере показана ошибочная ситуация, когда освобождение памяти не происходит, что подтверждает
вывод программы valgrind: утеряно 20 байт.

% TODO: описать спецификацию функции
\subsection{Освобождение памяти, выделенной функциями библиотеками С}
Необходимо точно знать спецификацию функций библиотек языка С. Некоторые из функций
выделяют блок памяти при вызове. Соответственно, выделеную память необходимо освобождть, иначе будет происходить
утечка памяти. В примере показано использование функции

Утечку памяти подтверждает вывод программы valgrind: утеряно 13 байт, так как один символ кодируется одним байтом,
строка содержит 12 печатных символов и один непачтный символ, обозначающий конец строки.


\subsection{Выделение блока памяти должно освобождаться его освобождением}
Довольно частая ошибка, когда программист забывает сделать освобождение выделенной
памяти. Далее, в разделе техник программирования, способствующих устранению ошибок,
связанных с работой с памятью, будут описаны методы, как избежать такой ситуации.
В примере показано, что была выделена память с помощью оператора new, но оператор
delete, который освобождает память, вызван не был, что приводит к утечке памяти.
ВЫвод программы valgrind подтверждает утечку: утеряно 60 байт. Тип int в языке С/С++
занимает 4 байта. Выделен массив под 15 элементов типа int, поэтому теряется 60 байт.

% TODO: как работает виртуальный десттруктор
\subsection{Наследование и работа с указателями}
Язык С++ позволяет привести указатель на объект дочернего класса к указателю на
базовый класс. В примере показано, что существует указатель на объект дочернего класса.
Заводится новый указатель с типом указателя на объект базового класса, адресом данного
указателя является адрес блока памяти, выделенного для дочернего класса. Производится удаление
указателя, указывающего на объект базового класса. Когда происходит удаление, то вызывается деструктор.
Правильное поведение программы заключается в том, что должна вызваться цепочка деструкторов: сначала базового,
потом дочернего. Однако в данном примере этого не происходит, так как деструктор дочернего класса не указан
как виртуальный. Соответственно, блок памяти, выделенный в конструкторе дочернего класса, не освободится,
что подтверждает вывод программы valgrind.

% TODO: переделать пример с использованием конструктора копирования и оператора присваивания
% и посмотреть с delete в деструкторе, что произойдет. Вообще, он должен быть
\subsection{Конструктор копирования по умолчанию и глубокое копирование}
Компилятор языка C++ создает конструктор копирования т оператор присваивания по умолчанию, если
таковые не определены программистом. Эти методы по умолчанию копируют значения полей. В примере
конструктор копирования и оператор присваивания не определены, поэтому будет производится копирование
значений, без выделения памяти. На сроке 15 создается объект, в конструкторе которого выделяется
блок памяти под 5 байт. После операции присваивания на строке 17 значение поля mData будет являеться
адресом, который указывает на блок памяти, выделенный при создании объекта a1. Соответственно, указатель
на блок памяти, выделенный при создании объекта a3, утерян, что приводит к утечке памяти.

%TODO: вот тут повнимательней прочитать
\subsection{Оператору new[] соответствует оператор delete[]}
Одной из ошибок, приводящей к утечке памяти, связано с невнимательностью разработчика.
Нужно запомнить, что оператору new[] соответствует оператор delete[]. ВЫвод программы valgrind подтверждает утечку памяти,
если использовать не тот оператор освобождения памяти. При вызове оператора delete без квадратных скобочек
удалится указатель, но не весь блок, выделенный под него.

\subsection{Выход за пределы массива}
Одной из частых проблем являеся попытка взятия элемента массива по индексу, который
выходит за пределы массива. Результатом ошибка при чтении является чтение мусора, при записи
может произойти критическое завершение программ или выброс исключения (в зависимости от реализации массива).
Такая ошибка детектируется с помощью синтаксических анализаторов, на слайде продемонстрирован вывод программы
cppcheck.

% \subsection{Освобождение ресурса или памяти, сформированной в статической памяти}
% Данная ошибка относится к группе тех, которыеы связаны с неосвобождением выделенной памяти,
% под ресурс или под объекты. Данная ошибка выделеа в отдельную группу, чтобы продемонстрировать
% вывод программы valgrind, он будет отличаться. Мы видим, что по завершению работы программы
% выделенная память не освободилась и остается все еще доступной.

\subsection{Советы}
Далее приведен список стандартных методов, которые позволяют избежать 
описанные проблемы. RAII идиома заключаетсяв том, что захват ресурса производится при инициализации
объекта, а освобождение --- при его разрушении. Для С++ это часто реализуется следующим образом:
в конструкторе производится захват ресура (открытие файла, коннекта к базе, сокету, локирование мьютекса и т.п.),
а в деструкторе освобождение ресурса.
\end{document}
